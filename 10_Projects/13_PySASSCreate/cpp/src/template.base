[Comment]
/**
 * 
 * ===========================================================================================================
 * IMPORTANT: This file is autogenerated. Do not change!!
 * ===========================================================================================================
 * 
 * This works as follows:
 *  - it is used as generator template for binaries containing one kernel for one variant of an instruction class
 *  - each binary potentially contains thousands of kernels
 *  - each template.cu.template gets renamed to [InstrClass].cu
 *  - each kernel template [K_[InstrClass]]_[ID] gets renamed to it's equivalend with K_*real instr class*_*some enumerated id*
 *  - [PARAMS] is what we get if we do
 *       x = target_cubin.create_instr(0, i, ii.class_name, ii.enc_vals)
 *       params = x.all_enc_vals
 *    and then transform the params to a string representation where easch SASS_Bits is represented with it's equivalent string
 *    in the same way as all enc_vals for example inside of sass_create_86.py
 * 
 * Every file contains the following components
 * 1. Comment: this exact your's truly section
 * 2. Includes: the portion with all relevant Cuda includes
 * 3. KernelT_iX: several up to thousands kernel templates that produces X instructions, for example KernelT_i60
 * 4. Main: one main function that includes one *Loop* for each of the *KernelT_iX*
 * 
 * This is a list containing all kernels in this file
 * [[AllKernelsList]]
 */
[/Comment]

[Includes]
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <iostream>
#include <fstream>
#include <algorithm>
#include <format>
#include <vector>
#include <stdint.h>
[/Includes]

[CMakeListsHeader]
cmake_minimum_required(VERSION 3.23)
set(CMAKE_CUDA_COMPILER "/usr/local/cuda/bin/nvcc")
project(kernel LANGUAGES C CXX CUDA)

# 1650 => 75, 3080 => 87
set(TARGET_PATH "/../../binaries/")

find_package(CUDAToolkit REQUIRED)
set(RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}")
set(LIBRARY_OUTPUT_PATH  "${CMAKE_BINARY_DIR}")

include_directories("/usr/local/cuda-12.8/include" "/usr/include")
add_subdirectory(src)
add_subdirectory(tests)

set(kernel_archs "[SmNr]")   
[/CMakeListsHeader]

[CMakeListsLoop]
# This loop builds the binaries for [BinName]
foreach(k ${kernel_archs})
   message("===== ${k} =====")

   set(nn "[BinName]_${k}.bin")
   add_executable(${nn} src/[BinName].cu)
   target_link_libraries(${nn} CUDA::cudart)
   target_link_libraries(${nn} CUDA::cuda_driver)
   set_property(TARGET ${nn} PROPERTY CUDA_ARCHITECTURES ${k})
   set_property(TARGET ${nn} PROPERTY CXX_STANDARD 20)
   add_custom_command(
        TARGET ${nn} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy
                ${CMAKE_CURRENT_BINARY_DIR}/${nn}
                ${CMAKE_CURRENT_BINARY_DIR}${TARGET_PATH}${nn})
endforeach()
[/CMakeListsLoop]

[KernelT_i60]
/**
 * ===========================================================================================================
 * This kernel can be used as template that produces around 60 (SM 70 to 86) to 75 (SM 90 to 120) instructions
 * ===========================================================================================================
 * Number of instructions can be modulated a little bit by setting
 *  - #pragma unroll 1 => fewest instructions
 *  - #pragma unroll 2 => around 60 to 75 instructions
 *  -  ...             => more than 60 to 75 instructions
 * 
 * Used enc_vals
 * =============
 * [PARAMS]
 */
__global__ void 
[K_[InstrClass]]_[ID](unsigned int a, uint64_t *control, uint64_t *ui_output, double* d_output, uint64_t* ui_input, double* d_input, uint64_t *clk_out_1, float* f_output) {
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        f_output[i] = static_cast<float>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    return;
}
[/KernelT_i60]

[LoopsHeader]
/**
* All instruction loops are in here:
* [[*Loops*]] gets replaced with
* [*InstrClass*]
*    [*Loop*] .. [*K_[*InstrClass*]*] .. [/*Loop*]
* [/*InstrClass*]
* where [*InstrClass*] represents the class of the current instruction that is being benchmarked.
* 
* 
*/
[/LoopsHeader]

[Main]
int main(int argc, char** argv){
    std::string fn = std::string(argv[0]);
    int split_ind = fn.find_last_of("/\\") + 1;
    std::string path = fn.substr(0,split_ind);
    std::string filename = fn.substr(split_ind);

    if(argc != 2){
        std::cout << std::vformat("{0} [input]", std::make_format_args(fn)) << std::endl;
        return 0;
    }
    unsigned int input = static_cast<unsigned int>(std::stoi(argv[1]));
    std::cout << "[Filename]" << filename << "[/Filename] [Input]" << input << "[/Input]" << std::endl;

    int loop_count = (input == 0) ? input++ : input;

    [[AllLoops]]  

    return 0;
}
[/Main]

[Loop]
std::cout << [K_[InstrClass]]_[ID] << std::endl;
for(int lp=0; lp<loop_count; ++lp){
    std::cout << "[LoopCount_" << lp << "]" << std::endl;
    // ==================================================================================================
    // Define input data
    // ==================================================================================================
    int control_size = 15;
    int printout = loop_count;
    std::vector<uint64_t> control(control_size);
    std::vector<uint64_t> ui_output(printout);
    std::vector<double> d_output(printout);
    std::vector<float> f_output(printout);
    std::vector<uint64_t> ui_input(printout);
    std::vector<double> d_input(printout);
    std::vector<uint64_t> clk_out_1(printout);
    for(int i=0; i<control.size(); ++i) control[i] = i+100;
    for(int i=0; i<ui_output.size(); ++i) ui_output[i] = i+1001;
    for(int i=0; i<d_output.size(); ++i) d_output[i] = static_cast<double>(i)+2001.2;
    for(int i=0; i<f_output.size(); ++i) f_output[i] = static_cast<float>(i)+3001.3;
    for(int i=0; i<ui_input.size(); ++i) ui_input[i] = 0;
    for(int i=0; i<d_input.size(); ++i) d_input[i] = 0.0;
    for(int i=0; i<clk_out_1.size(); ++i) clk_out_1[i] = 999999998;

    // ==================================================================================================
    // Print input data
    // ==================================================================================================
    std::cout << "[BeforeKernel]" << std::endl;
    std::cout << " + [C] Before kernel " << filename << std::endl << "       finished: control(i)[";
    for(int i=0; i<control_size; ++i) {
        std::cout << i;
        if(i<(control_size-1)) std::cout << ", ";
    }
    std::cout << "] = [Control]" << std::endl << "                   ";
    for(int i=0; i<control_size; ++i){
        std::cout << control[i];
        if(i<(control_size-1)) std::cout << ", ";
    }
    std::cout << "[/Control]" << std::endl;

    std::cout << " + [IO] Before kernel " << filename << std::endl << "       finished: ui_output(i)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [UiOutput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << ui_output[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/UiOutput]" << std::endl;

    std::cout << " + [DO] Before kernel " << filename << std::endl << "       finished: d_output(d)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [DOutput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << d_output[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/DOutput]" << std::endl;

    std::cout << " + [FO] Before kernel " << filename << std::endl << "       finished: f_output(f)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [FOutput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << f_output[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/FOutput]" << std::endl;

    std::cout << " + [II] Before kernel " << filename << std::endl << "       finished: ui_input(i)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [UiInput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << ui_input[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/UiInput]" << std::endl;

    std::cout << " + [DI] Before kernel " << filename << std::endl << "       finished: d_input(d)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [DInput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << d_input[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/DInput]" << std::endl;

    std::cout << " + [C1] Before kernel " << filename << std::endl << "       finished: clk_out_1(i)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [ClkOut1]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << clk_out_1[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/ClkOut1]" << std::endl;

    std::cout <<" + [.][Before kernel] [UiInput0]" << ui_input[0] << "[/UiInput0], [DInput0]" << d_input[0] << "[/DInput0]" << std::endl;

    // ==================================================================================================
    // Copy input data to GPU
    // ==================================================================================================
    uint64_t* device_control;
    cudaMalloc(&device_control, control.size()*sizeof(uint64_t));
    cudaMemcpy(device_control, control.data(), control.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    uint64_t* device_ui_output;
    cudaMalloc(&device_ui_output, ui_output.size()*sizeof(uint64_t));
    cudaMemcpy(device_ui_output, ui_output.data(), ui_output.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    double* device_d_output;
    cudaMalloc(&device_d_output, d_output.size()*sizeof(double));
    cudaMemcpy(device_d_output, d_output.data(), d_output.size()*sizeof(double), cudaMemcpyHostToDevice);

    float* device_f_output;
    cudaMalloc(&device_f_output, f_output.size()*sizeof(float));
    cudaMemcpy(device_f_output, f_output.data(), f_output.size()*sizeof(float), cudaMemcpyHostToDevice);

    uint64_t* device_ui_input;
    cudaMalloc(&device_ui_input, ui_input.size()*sizeof(uint64_t));
    cudaMemcpy(device_ui_input, ui_input.data(), ui_input.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    double* device_d_input;
    cudaMalloc(&device_d_input, d_input.size()*sizeof(double));
    cudaMemcpy(device_d_input, d_input.data(), d_input.size()*sizeof(double), cudaMemcpyHostToDevice);

    uint64_t* device_clk_out_1;
    cudaMalloc(&device_clk_out_1, clk_out_1.size()*sizeof(uint64_t));
    cudaMemcpy(device_clk_out_1, clk_out_1.data(), clk_out_1.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    std::cout << "[/BeforeKernel]" << std::endl;
    // ==================================================================================================
    // Run Kernel
    // ==================================================================================================
    [K_[InstrClass]]<<<1,1>>>(input, device_control, device_ui_output, device_d_output, device_ui_input, device_d_input, device_clk_out_1, device_f_output);

    cudaDeviceSynchronize();
    cudaError_t err = cudaGetLastError();
    if ( err != cudaSuccess ) {
        std::cout << "[CUDAError]" << cudaGetErrorString(err) << "[/CUDAError]" << std::endl;
    }

    std::cout << "[AfterKernel]" << std::endl;

    // ==================================================================================================
    // Copy output data to CPU
    // ==================================================================================================
    cudaMemcpy(control.data(), device_control, control.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(ui_output.data(), device_ui_output, ui_output.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(d_output.data(), device_d_output, d_output.size()*sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_output.data(), device_f_output, f_output.size()*sizeof(float), cudaMemcpyDeviceToHost);
    cudaMemcpy(ui_input.data(), device_ui_input, ui_input.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(d_input.data(), device_d_input, d_input.size()*sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(clk_out_1.data(), device_clk_out_1, clk_out_1.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaFree(device_control);
    cudaFree(device_ui_output);
    cudaFree(device_d_output);
    cudaFree(device_f_output);
    cudaFree(device_ui_input);
    cudaFree(device_d_input);
    cudaFree(device_clk_out_1);

    // ==================================================================================================
    // Print output data
    // ==================================================================================================
    std::cout << " + [C] After kernel " << filename << std::endl << "       finished: control(i)[";
    for(int i=0; i<control_size; ++i) {
        std::cout << i;
        if(i<(control_size-1)) std::cout << ", ";
    }
    std::cout << "] = [Control]" << std::endl << "                   ";
    for(int i=0; i<control_size; ++i){
        std::cout << control[i];
        if(i<(control_size-1)) std::cout << ", ";
    }
    std::cout << "[/Control]" << std::endl;

    std::cout << " + [I] After kernel " << filename << std::endl << "       finished: ui_output(i)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [UiOutput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << ui_output[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/UiOutput]" << std::endl;

    std::cout << " + [D] After kernel " << filename << std::endl << "       finished: d_output(d)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [DOutput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << d_output[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/DOutput]" << std::endl;

    std::cout << " + [F] After kernel " << filename << std::endl << "       finished: f_output(f)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [FOutput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << f_output[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/FOutput]" << std::endl;

    std::cout << " + [II] After kernel " << filename << std::endl << "       finished: ui_input(i)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [UiInput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << ui_input[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/UiInput]" << std::endl;

    std::cout << " + [DI] After kernel " << filename << std::endl << "       finished: d_input(d)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [DInput]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << d_input[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/DInput]" << std::endl;

    std::cout << " + [C1] After kernel " << filename << std::endl << "       finished: clk_out_1(i)[";
    for(int i=0; i<printout; ++i) {
        std::cout << i;
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "] = [ClkOut1]" << std::endl << "                   ";
    for(int i=0; i<printout; ++i){
        std::cout << clk_out_1[i];
        if(i<(printout-1)) std::cout << ", ";
    }
    std::cout << "[/ClkOut1]" << std::endl;

    std::cout <<" + [.][After kernel] [UiInput0]" << ui_input[0] << "[/UiInput0], [DInput0]" << d_input[0] << "[/DInput0]" << std::endl;
    std::cout << "[/AfterKernel]" << std::endl;

    std::cout << "[/LoopCount_" << lp << "]" << std::endl;
}
std::cout << [/K_[InstrClass]]_[ID] << std::endl;
[/Loop]