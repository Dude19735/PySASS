"""
This file contains a template generator for Cuda kernels. Each template consists of the following parts:
* Comment: A comment pointing out what the .cu file that will be generated is and also containing the number of kernels
* Includes: The necessary includes for the .cu file to be compilable 
* CMakeListHeader: CMakeLists header, containing the usual boilerplate stuff
* CMakeListLoop: a CMakeLists compilation loop that creates binaries for the given architectures (SM 50 to SM 120)
* Kernels: a list of kernels, each one the same, with enumerated names
* RunTest: a generic method that runs each kernel with some input
* Main: the main() method of the .cu file

A template requires enc_vals, as generated by the py_sass module as a string. Any script that uses the template must prepare a file
named [.cu-filename]_[arch]_enc_vals.txt, containing at most as many enc_val dictionaries as the template contains kernels.

The template can be generated with a custom nr of kernels. A good number is 3000. It doesn't explode the RAM while compiling 
and doesn't take too long to load.

The generated template binaries *must* be loaded with SM_CuBin_File(sass, filename, wipe=True). The 'wipe' argument will
cause SM_CuBin_File to not parse all 3000 kernels but simply replace all instructions with the SM version befitting NOP instruction.

Decoding is much more involved than assembling to a runnable binary, since the decoding process has to match all instruction classes,
which can take a while, then calculate all possible universe variations for each of them, which can take another while. Doing that
for 3000 kernels with more than 60 instructions each probably takes hours. Loading a 3000 kernel template with wipe=True should take
something in the range of 15 seconds, assembling it to a new binary with to_exec should take around 10 seconds.
"""

import os
import sys
import shutil
import typing
import termcolor as tc
from py_cubin import SM_CuBin_File
from py_sass import SM_SASS
sys.path.append("/".join(os.path.dirname(os.path.realpath(__file__)).split('/')[:-1]))

class AllKernelShipPieces:
    FileName = '[[FileName]]'
    ID = '[[ID]]'
    KernelArchs = '[[KernelArchs]]'
    KernelNames = '[[KernelNames]]'
    KernelAddresses = '[[KernelAddresses]]'
    KernelCount = '[[KernelCount]]'

    Arch = 'set(kernel_archs {0})'

    Comment = """
/**
 * 
 * ===========================================================================================================
 * IMPORTANT: This file is autogenerated. Do not change!!
 * ===========================================================================================================
 * [KernelCount][[KernelCount]][/KernelCount]
 */"""

    Includes = """#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <iostream>
#include <fstream>
#include <algorithm>
#include <thread>
#include <format>
#include <vector>
#include <chrono>
#include <map>
#include <string>
#include <unordered_map>
#include <stdint.h>"""

    CMakeListsHeader = """cmake_minimum_required(VERSION 3.23)
set(CMAKE_CUDA_COMPILER "/usr/local/cuda/bin/nvcc")
project(kernel LANGUAGES C CXX CUDA)

# 1650 => 75, 3080 => 87
set(TARGET_PATH "/../benchmark_binaries/")

find_package(CUDAToolkit REQUIRED)
set(RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}")
set(LIBRARY_OUTPUT_PATH  "${CMAKE_BINARY_DIR}")

include_directories("/usr/local/cuda-12.8/include" "/usr/include")
add_subdirectory(src)
add_subdirectory(tests)

[[KernelArchs]]"""

    CMakeListsLoop = """# This loop builds the binaries for [[FileName]]
foreach(k ${kernel_archs})
   message("===== ${k} =====")

   set(nn "[[FileName]]_${k}.bin")
   add_executable(${nn} src/[[FileName]].cu)
   target_link_libraries(${nn} CUDA::cudart)
   target_link_libraries(${nn} CUDA::cuda_driver)
   set_property(TARGET ${nn} PROPERTY CUDA_ARCHITECTURES ${k})
   set_property(TARGET ${nn} PROPERTY CXX_STANDARD 20)
   add_custom_command(
        TARGET ${nn} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy
                ${CMAKE_CURRENT_BINARY_DIR}/${nn}
                ${CMAKE_CURRENT_BINARY_DIR}${TARGET_PATH}${nn})
endforeach()"""

    KernelT_i60 = """__global__ void 
Kernel_[[ID]](unsigned int a, uint64_t *control, uint64_t *ui_output, double* d_output, uint64_t* ui_input, double* d_input, uint64_t *clk_out_1, float* f_output) {
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        f_output[i] = static_cast<float>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    return;
}"""

    KernelT_i120 = """__global__ void 
Kernel_[[ID]](unsigned int a, uint64_t *control, uint64_t *ui_output, double* d_output, uint64_t* ui_input, double* d_input, uint64_t *clk_out_1, float* f_output) {
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        ui_output[i] = static_cast<int>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        d_output[i] = 4.258798258 + static_cast<double>(a + static_cast<int>(a * (static_cast<float>(t2-t1) + 1.375f)));
    }
    return;
}"""

    KernelT_i240 = """__global__ void 
Kernel_[[ID]](unsigned int a, uint64_t *control, uint64_t *ui_output, double* d_output, uint64_t* ui_input, double* d_input, uint64_t *clk_out_1, float* f_output) {
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        ui_output[i] = static_cast<int>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        d_output[i] = 4.258798258 + static_cast<double>(a + static_cast<int>(a * (static_cast<float>(t2-t1) + 1.375f)));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        ui_output[i] = static_cast<int>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        d_output[i] = 4.258798258 + static_cast<double>(a + static_cast<int>(a * (static_cast<float>(t2-t1) + 1.375f)));
    }
    return;
}"""

    RunTest = """template<class T>
void print_out(const std::string& prefix, const std::string& label, const std::vector<T>& data) {
    size_t ss = data.size();
    std::cout << prefix << "[" << label << "]";
    for(int i=0; i<ss; ++i){
        std::cout << data[i];
        if(i<(ss-1)) std::cout << ", ";
    }
    std::cout << "[/" << label << "]" << std::endl;
}

void print_out_single(const std::string& prefix, const std::string& label, const char* data) {
    std::cout << prefix << "[" << label << "]" << data << "[/" << label << "]" << std::endl;
}

int run_test(void* kernel_ptr, int input, int loop_count, const std::string& filename, int kernel_index, const std::string& kernel_name, const std::string& enc_vals, const std::vector<uint64_t>& ui_input_params){
    std::cout << "[Kernel_" << kernel_index << "]" << std::endl;
    
    // print enc vals
    std::cout << "[EncVals]" << std::endl;
    std::cout << kernel_name << "|" << enc_vals << std::endl;
    std::cout << "[/EncVals]" << std::endl;

    uint64_t addr = reinterpret_cast<uint64_t>(kernel_ptr);
    std::cout << "[KernelAddress]0x" << std::format("{:x}", addr) << "[/KernelAddress]" << std::endl; 

    for(int lp=0; lp<loop_count; ++lp){
        std::cout << "   [LoopCount_" << lp << "]" << std::endl;
        // ==================================================================================================
        // Define input data
        // ==================================================================================================
        int control_size = 15;
        int printout = loop_count;
        std::vector<uint64_t> control(control_size);
        std::vector<uint64_t> ui_output(printout);
        std::vector<double> d_output(printout);
        std::vector<float> f_output(printout);
        std::vector<uint64_t> ui_input(printout);
        std::vector<double> d_input(printout);
        std::vector<uint64_t> clk_out_1(printout);
        for(int i=0; i<control.size(); ++i) control[i] = 0;
        for(int i=0; i<ui_output.size(); ++i) ui_output[i] = 0;
        for(int i=0; i<d_output.size(); ++i) d_output[i] = 0.0;
        for(int i=0; i<f_output.size(); ++i) f_output[i] = static_cast<float>(i+10001);;
        // Use some of user defined input, if it exists
        for(size_t i=0; i<ui_input_params.size(); ++i) ui_input[i] = ui_input_params[i];
        for(size_t i=ui_input_params.size(); i<ui_input.size(); ++i) ui_input[i] = i+10001;
        for(int i=0; i<d_input.size(); ++i) d_input[i] = static_cast<double>(i+10001);
        for(int i=0; i<clk_out_1.size(); ++i) clk_out_1[i] = 999999998;

        // ==================================================================================================
        // Print input data
        // ==================================================================================================
        std::cout << "      [BeforeKernel]" << std::endl;
        print_out("         ", "Control", control);
        print_out("         ", "UiOutput", ui_output);
        print_out("         ", "DOutput", d_output);
        print_out("         ", "FOutput", f_output);
        print_out("         ", "UiInput", ui_input);
        print_out("         ", "DInput", d_input);
        print_out("         ", "ClkOut1", clk_out_1);

        // ==================================================================================================
        // Copy input data to GPU
        // ==================================================================================================
        uint64_t* device_control;
        cudaMalloc(&device_control, control.size()*sizeof(uint64_t));
        cudaMemcpy(device_control, control.data(), control.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

        uint64_t* device_ui_output;
        cudaMalloc(&device_ui_output, ui_output.size()*sizeof(uint64_t));
        cudaMemcpy(device_ui_output, ui_output.data(), ui_output.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

        double* device_d_output;
        cudaMalloc(&device_d_output, d_output.size()*sizeof(double));
        cudaMemcpy(device_d_output, d_output.data(), d_output.size()*sizeof(double), cudaMemcpyHostToDevice);

        float* device_f_output;
        cudaMalloc(&device_f_output, f_output.size()*sizeof(float));
        cudaMemcpy(device_f_output, f_output.data(), f_output.size()*sizeof(float), cudaMemcpyHostToDevice);

        uint64_t* device_ui_input;
        cudaMalloc(&device_ui_input, ui_input.size()*sizeof(uint64_t));
        cudaMemcpy(device_ui_input, ui_input.data(), ui_input.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

        double* device_d_input;
        cudaMalloc(&device_d_input, d_input.size()*sizeof(double));
        cudaMemcpy(device_d_input, d_input.data(), d_input.size()*sizeof(double), cudaMemcpyHostToDevice);

        uint64_t* device_clk_out_1;
        cudaMalloc(&device_clk_out_1, clk_out_1.size()*sizeof(uint64_t));
        cudaMemcpy(device_clk_out_1, clk_out_1.data(), clk_out_1.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

        std::cout << "      [/BeforeKernel]" << std::endl;
        // ==================================================================================================
        // Run Kernel
        // ==================================================================================================
        // kernelT<<<1,1>>>(input, device_control, device_ui_output, device_d_output, device_ui_input, device_d_input, device_clk_out_1, device_f_output);
        void* args[] = {&input, &device_control, &device_ui_output, &device_d_output, &device_ui_input, &device_d_input, &device_clk_out_1, &device_f_output};
        cudaError_t err;
        err = cudaLaunchKernel(kernel_ptr, 1, 1, args, 0, nullptr);
        if ( err != cudaSuccess ) {
            print_out_single("         ", "CUDAError", cudaGetErrorString(err));
        }

        err = cudaDeviceSynchronize();
        if ( err != cudaSuccess ) {
            print_out_single("         ", "CUDAError", cudaGetErrorString(err));
        }

        err = cudaGetLastError();
        if ( err != cudaSuccess ) {
            print_out_single("         ", "CUDAError", cudaGetErrorString(err));
        }

        std::cout << "      [AfterKernel]" << std::endl;

        // ==================================================================================================
        // Copy output data to CPU
        // ==================================================================================================
        cudaMemcpy(control.data(), device_control, control.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
        cudaMemcpy(ui_output.data(), device_ui_output, ui_output.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
        cudaMemcpy(d_output.data(), device_d_output, d_output.size()*sizeof(double), cudaMemcpyDeviceToHost);
        cudaMemcpy(f_output.data(), device_f_output, f_output.size()*sizeof(float), cudaMemcpyDeviceToHost);
        cudaMemcpy(ui_input.data(), device_ui_input, ui_input.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
        cudaMemcpy(d_input.data(), device_d_input, d_input.size()*sizeof(double), cudaMemcpyDeviceToHost);
        cudaMemcpy(clk_out_1.data(), device_clk_out_1, clk_out_1.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
        cudaFree(device_control);
        cudaFree(device_ui_output);
        cudaFree(device_d_output);
        cudaFree(device_f_output);
        cudaFree(device_ui_input);
        cudaFree(device_d_input);
        cudaFree(device_clk_out_1);

        // ==================================================================================================
        // Print output data
        // ==================================================================================================
        print_out("         ", "Control", control);
        print_out("         ", "UiOutput", ui_output);
        print_out("         ", "DOutput", d_output);
        print_out("         ", "FOutput", f_output);
        print_out("         ", "UiInput", ui_input);
        print_out("         ", "DInput", d_input);
        print_out("         ", "ClkOut1", clk_out_1);

        std::cout << "      [/AfterKernel]" << std::endl;
        std::cout << "   [/LoopCount_" << lp << "]" << std::endl;
    }
    std::cout << "[/Kernel_" << kernel_index << "]" << std::endl;

    return 0;
}"""

    KernelAddressTemplate = '"Kernel_{0}", reinterpret_cast<void*>(&Kernel_{0})'

    GITIGNORE = """# Prerequisites
*.d

# Compiled Object files
*.slo
*.lo
*.o
*.obj

# Precompiled Headers
*.gch
*.pch

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la
*.a
*.lib

# Executables
*.exe
*.out
*.in
*.app

/__pycache__/*
/*/__pycache__/*
/build/*
"""

    RunTestNoLoop = """template<class T>
void print_out(const std::string& prefix, const std::string& label, const std::vector<T>& data) {
    size_t ss = data.size();
    std::cout << prefix << "[" << label << "]";
    for(int i=0; i<ss; ++i){
        std::cout << data[i];
        if(i<(ss-1)) std::cout << ", ";
    }
    std::cout << "[/" << label << "]" << std::endl;
}

void print_out_single(const std::string& prefix, const std::string& label, const char* data) {
    std::cout << prefix << "[" << label << "]" << data << "[/" << label << "]" << std::endl;
}

int run_test(void* kernel_ptr, unsigned int input, unsigned int data_size, const std::string& filename, int kernel_index, const std::string& kernel_name, const std::string& enc_vals, const std::vector<uint64_t>& ui_input_params){
    std::cout << "[Kernel_" << kernel_index << "]" << std::endl;
    
    // print enc vals
    std::cout << "[EncVals]" << std::endl;
    std::cout << kernel_name << "|" << enc_vals << std::endl;
    std::cout << "[/EncVals]" << std::endl;

    uint64_t addr = reinterpret_cast<uint64_t>(kernel_ptr);
    std::cout << "[KernelAddress]0x" << std::format("{:x}", addr) << "[/KernelAddress]" << std::endl; 

    std::cout << "   [LoopCount_0]" << std::endl;
    // ==================================================================================================
    // Define input data
    // ==================================================================================================
    int control_size = 15;
    int printout = data_size;
    std::vector<uint64_t> control(control_size);
    std::vector<uint64_t> ui_output(printout);
    std::vector<double> d_output(printout);
    std::vector<float> f_output(printout);
    std::vector<uint64_t> ui_input(printout);
    std::vector<double> d_input(printout);
    std::vector<uint64_t> clk_out_1(printout);
    for(int i=0; i<control.size(); ++i) control[i] = 0;
    for(int i=0; i<ui_output.size(); ++i) ui_output[i] = 0;
    for(int i=0; i<d_output.size(); ++i) d_output[i] = 0.0;
    for(int i=0; i<f_output.size(); ++i) f_output[i] = static_cast<float>(i+10001);;
    // Use some of user defined input, if it exists
    for(size_t i=0; i<ui_input_params.size(); ++i) ui_input[i] = ui_input_params[i];
    for(size_t i=ui_input_params.size(); i<ui_input.size(); ++i) ui_input[i] = i+10001;
    for(int i=0; i<d_input.size(); ++i) d_input[i] = static_cast<double>(i+10001);
    for(int i=0; i<clk_out_1.size(); ++i) clk_out_1[i] = 999999998;

    // ==================================================================================================
    // Print input data
    // ==================================================================================================
    std::cout << "      [BeforeKernel]" << std::endl;
    print_out("         ", "Control", control);
    print_out("         ", "UiOutput", ui_output);
    print_out("         ", "DOutput", d_output);
    print_out("         ", "FOutput", f_output);
    print_out("         ", "UiInput", ui_input);
    print_out("         ", "DInput", d_input);
    print_out("         ", "ClkOut1", clk_out_1);

    // ==================================================================================================
    // Copy input data to GPU
    // ==================================================================================================
    uint64_t* device_control;
    cudaMalloc(&device_control, control.size()*sizeof(uint64_t));
    cudaMemcpy(device_control, control.data(), control.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    uint64_t* device_ui_output;
    cudaMalloc(&device_ui_output, ui_output.size()*sizeof(uint64_t));
    cudaMemcpy(device_ui_output, ui_output.data(), ui_output.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    double* device_d_output;
    cudaMalloc(&device_d_output, d_output.size()*sizeof(double));
    cudaMemcpy(device_d_output, d_output.data(), d_output.size()*sizeof(double), cudaMemcpyHostToDevice);

    float* device_f_output;
    cudaMalloc(&device_f_output, f_output.size()*sizeof(float));
    cudaMemcpy(device_f_output, f_output.data(), f_output.size()*sizeof(float), cudaMemcpyHostToDevice);

    uint64_t* device_ui_input;
    cudaMalloc(&device_ui_input, ui_input.size()*sizeof(uint64_t));
    cudaMemcpy(device_ui_input, ui_input.data(), ui_input.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    double* device_d_input;
    cudaMalloc(&device_d_input, d_input.size()*sizeof(double));
    cudaMemcpy(device_d_input, d_input.data(), d_input.size()*sizeof(double), cudaMemcpyHostToDevice);

    uint64_t* device_clk_out_1;
    cudaMalloc(&device_clk_out_1, clk_out_1.size()*sizeof(uint64_t));
    cudaMemcpy(device_clk_out_1, clk_out_1.data(), clk_out_1.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    std::cout << "      [/BeforeKernel]" << std::endl;
    // ==================================================================================================
    // Run Kernel
    // ==================================================================================================
    // kernelT<<<1,1>>>(input, device_control, device_ui_output, device_d_output, device_ui_input, device_d_input, device_clk_out_1, device_f_output);
    void* args[] = {&input, &device_control, &device_ui_output, &device_d_output, &device_ui_input, &device_d_input, &device_clk_out_1, &device_f_output};
    cudaError_t err;
    err = cudaLaunchKernel(kernel_ptr, 1, 1, args, 0, nullptr);
    if ( err != cudaSuccess ) {
        print_out_single("         ", "CUDAError", cudaGetErrorString(err));
    }

    err = cudaDeviceSynchronize();
    if ( err != cudaSuccess ) {
        print_out_single("         ", "CUDAError", cudaGetErrorString(err));
    }

    err = cudaGetLastError();
    if ( err != cudaSuccess ) {
        print_out_single("         ", "CUDAError", cudaGetErrorString(err));
    }

    std::cout << "      [AfterKernel]" << std::endl;

    // ==================================================================================================
    // Copy output data to CPU
    // ==================================================================================================
    cudaMemcpy(control.data(), device_control, control.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(ui_output.data(), device_ui_output, ui_output.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(d_output.data(), device_d_output, d_output.size()*sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_output.data(), device_f_output, f_output.size()*sizeof(float), cudaMemcpyDeviceToHost);
    cudaMemcpy(ui_input.data(), device_ui_input, ui_input.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(d_input.data(), device_d_input, d_input.size()*sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(clk_out_1.data(), device_clk_out_1, clk_out_1.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaFree(device_control);
    cudaFree(device_ui_output);
    cudaFree(device_d_output);
    cudaFree(device_f_output);
    cudaFree(device_ui_input);
    cudaFree(device_d_input);
    cudaFree(device_clk_out_1);

    // ==================================================================================================
    // Print output data
    // ==================================================================================================
    print_out("         ", "Control", control);
    print_out("         ", "UiOutput", ui_output);
    print_out("         ", "DOutput", d_output);
    print_out("         ", "FOutput", f_output);
    print_out("         ", "UiInput", ui_input);
    print_out("         ", "DInput", d_input);
    print_out("         ", "ClkOut1", clk_out_1);

    std::cout << "      [/AfterKernel]" << std::endl;
    std::cout << "   [/LoopCount_0]" << std::endl;

    std::cout << "[/Kernel_" << kernel_index << "]" << std::endl;

    return 0;
}"""
