"""
TODO: this one needs an adjusted comment!!


This file contains a template generator for Cuda kernels. Each template consists of the following parts:
* Comment: A comment pointing out what the .cu file that will be generated is and also containing the number of kernels
* Includes: The necessary includes for the .cu file to be compilable 
* CMakeListHeader: CMakeLists header, containing the usual boilerplate stuff
* CMakeListLoop: a CMakeLists compilation loop that creates binaries for the given architectures (SM 50 to SM 120)
* Kernels: a list of kernels, each one the same, with enumerated names
* RunTest: a generic method that runs each kernel with some input
* Main: the main() method of the .cu file

A template requires enc_vals, as generated by the py_sass module as a string. Any script that uses the template must prepare a file
named [.cu-filename]_[arch]_enc_vals.txt, containing at most as many enc_val dictionaries as the template contains kernels.

The template can be generated with a custom nr of kernels. A good number is 3000. It doesn't explode the RAM while compiling 
and doesn't take too long to load.

The generated template binaries *must* be loaded with SM_CuBin_File(sass, filename, wipe=True). The 'wipe' argument will
cause SM_CuBin_File to not parse all 3000 kernels but simply replace all instructions with the SM version befitting NOP instruction.

Decoding is much more involved than assembling to a runnable binary, since the decoding process has to match all instruction classes,
which can take a while, then calculate all possible universe variations for each of them, which can take another while. Doing that
for 3000 kernels with more than 60 instructions each probably takes hours. Loading a 3000 kernel template with wipe=True should take
something in the range of 15 seconds, assembling it to a new binary with to_exec should take around 10 seconds.
"""

import os
import sys
import shutil
import typing
import termcolor as tc
from py_cubin import SM_CuBin_File
from py_sass import SM_SASS
sys.path.append("/".join(os.path.dirname(os.path.realpath(__file__)).split('/')[:-1]))
from kernel_w_loop_template_gen import AllKernelShipPieces

class Generator:
    Main = """int main(int argc, char** argv){
    std::string fn = std::string(argv[0]);
    int split_ind = fn.find_last_of("/") + 1;
    std::string path = fn.substr(0,split_ind);
    std::string filename = fn.substr(split_ind);

    if(argc < 2){
        std::cout << std::vformat("{0} [input] [bin_location]", std::make_format_args(fn)) << std::endl;
        std::cout << " * [input]: an integer denoting how many inner loops all kernels do" << std::endl;
        return 0;
    }
    unsigned int input = static_cast<unsigned int>(std::stoi(argv[1]));
    int loop_count = (input == 0) ? input++ : input;

    std::cout << "[Filename]" << filename << "[/Filename] [Input]" << input << "[/Input] ";

    std::map<std::string, void*> kernel_ptr = {{"Kernel_0", reinterpret_cast<void*>(&Kernel_0)}};
    
    std::vector<uint64_t> ui_input_params;
    for(int i=2; i<argc; ++i) ui_input_params.push_back(std::stoi(argv[i]));
    
    run_test(kernel_ptr["Kernel_0"], input, loop_count, filename, 0, "Kernel_0", "", ui_input_params);

    return 0;
}"""

    @staticmethod
    def gen_kernel(location:str, file_name:str, min_arch:int, max_arch:int, implicit_delete=False, instr_num:int=60):
        num_kernels:int = 1

        if not (50<=min_arch and min_arch <= max_arch and max_arch<=120): raise Exception("Only architectures 50 to 120 are supported")
        if not instr_num in (60, 120): raise Exception("Only 60 or 120 instructions are supported")

        arch_dict = {50:0, 52:1, 53:2, 60:3, 61:4, 62:5, 70:6, 72:7, 75:8, 80:9, 86:10, 90:11, 100:12, 120:13}
        arch_list = ['"50"', '"52"', '"53"', '"60"', '"61"', '"62"', '"70"', '"72"', '"75"', '"80"', '"86"', '"90"', '"100"', '"120"']

        arch:str = AllKernelShipPieces.Arch.format(" ".join([arch_list[i] for a,i in arch_dict.items() if min_arch <= a and a <= max_arch]))

        Comment = AllKernelShipPieces.Comment.replace(AllKernelShipPieces.KernelCount, str(num_kernels))
        Includes = AllKernelShipPieces.Includes
        CMakeListHeader = arch.join(AllKernelShipPieces.CMakeListsHeader.split(AllKernelShipPieces.KernelArchs))
        CMakeListLoop = file_name.join(AllKernelShipPieces.CMakeListsLoop.split(AllKernelShipPieces.FileName))
        if instr_num == 60:
            Kernels = [AllKernelShipPieces.KernelT_i60.replace(AllKernelShipPieces.ID, str(i)) for i in range(num_kernels)]
        elif instr_num == 120:
            Kernels = [AllKernelShipPieces.KernelT_i120.replace(AllKernelShipPieces.ID, str(i)) for i in range(num_kernels)]
        else: raise Exception("Unsupported instruction number")
        RunTest = AllKernelShipPieces.RunTest
        
        Main = Generator.Main.replace(AllKernelShipPieces.KernelAddresses, ",".join(["{" + AllKernelShipPieces.KernelAddressTemplate.format(i) + "}" for i in range(num_kernels)]))
        Main = Main.replace(AllKernelShipPieces.KernelCount, str(num_kernels))

        cu_file = "{0}\n\n{1}\n\n{2}\n\n{3}\n\n{4}".format(Comment, Includes, "\n\n".join(Kernels), RunTest, Main)
        cmake_file = "{0}\n\n{1}".format(CMakeListHeader, CMakeListLoop)
        
        if implicit_delete and os.path.exists(location): shutil.rmtree(location)
        os.mkdir(location)
        os.mkdir("{0}/src".format(location))
        os.mkdir("{0}/tests".format(location))

        # Need to put empty CMakeLists.txt in each folder
        with open("{0}/src/CMakeLists.txt".format(location), 'w') as f: pass
        with open("{0}/tests/CMakeLists.txt".format(location), 'w') as f: pass

        with open("{0}/CMakeLists.txt".format(location), 'w') as f:
            f.write(cmake_file)

        with open("{0}/src/{1}.cu".format(location, file_name), 'w') as f:
            f.write(cu_file)

        with open("{0}/.gitignore".format(location), 'w') as f:
            f.write(AllKernelShipPieces.GITIGNORE)
        
        print("Finished")

if __name__ == '__main__':
    gg = True
    name = 'template_1k_120'
    location = os.path.dirname(os.path.realpath(__file__)) + "/template_projects/" + name
    filename = name
    
    if gg:
        Generator.gen_kernel(location, filename, 75, 75, implicit_delete=False, instr_num=120)
        exit(0)

    import datetime
    sm_nr = 86
    f_filename = "{0}/benchmark_binaries/{1}".format(location, "{0}_{1}".format(filename, sm_nr))
    sass = SM_SASS(sm=sm_nr)
    t1 = datetime.datetime.now()
    cubin = SM_CuBin_File(sass, f_filename, wipe=True)
    t2 = datetime.datetime.now()
    print("Load:", t2-t1)

    t1 = datetime.datetime.now()
    cubin.to_exec(f_filename + ".mod")
    t2 = datetime.datetime.now()
    print("Store:", t2-t1)
    pass
