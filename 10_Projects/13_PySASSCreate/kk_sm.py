from __future__ import annotations
import typing
import os
import pickle
import requests
import gzip
import time
import struct
from py_sass_ext import SASS_Bits
from py_sass_ext import BitVector
from py_sass import SM_SASS
from py_cubin import SM_CuBin_Lib
from py_cubin import SM_CuBin_Regs
from py_cubin import SM_CuBin_Service_Lib
import _config as sp

class KK_SM:
    def __init__(self, sm_nr:int, ip:str, port:int, webload=True, load_encdom=False):
        if not isinstance(sm_nr, int): raise Exception(sp.CONST__ERROR_ILLEGAL)
        if not isinstance(ip, str): raise Exception(sp.CONST__ERROR_ILLEGAL)
        if not isinstance(port, int): raise Exception(sp.CONST__ERROR_ILLEGAL)
        self.__sm_nr = sm_nr
        self.__url = SM_CuBin_Lib.get_url(ip, port)
        if webload:
            print("Webloading sass {0} object...".format(sm_nr))
            t1 = time.time()
            data = b'\xc8' + struct.pack('!i',sm_nr)
            response = requests.post(self.__url, data=data)
            self.__sass = pickle.loads(gzip.decompress(response.content))
            print("... ok [{0}]".format(time.time() - t1))
        else:
            print("Loading sass {0} object".format(sm_nr))
            t1 = time.time()
            self.__sass = SM_SASS(sm_nr)
            if load_encdom: self.__sass.load_encdom()
            print("... ok [{0}]".format(time.time() - t1))
        self.__regs = SM_CuBin_Regs(self.__sass.sm.details.REGISTERS_DICT)
        print("Calc KK_Instr...")
        t1 = time.time()
        print("... ok [{0}]".format(time.time() - t1))

        # fn_kk_instr = 'sm_{0}_kk_instr.pickle'.format(sm_nr)
        # location = os.path.dirname(os.path.realpath(__file__)) + '/resources'
        # if not os.path.exists(location): os.mkdir(location)
        # if calc_kk_instr or not os.path.exists(location + "/" + fn_kk_instr):
        #     print("Calc KK_Instr...")
        #     t1 = time.time()
        #     self.__kk_instr = {c:KK_Instr(self.__sass, self.__sm_props, i) for c,i in self.__sass.sm.classes_dict.items()}
        #     with open(location + "/" + fn_kk_instr, 'wb') as f:
        #         pickle.dump(self.__kk_instr, f)
        #     print("... ok [{0}]".format(time.time() - t1))
        # else:
        #     print("Load KK_Instr...")
        #     t1 = time.time()
        #     with open(location + "/" + fn_kk_instr, 'rb') as f: self.__kk_instr = pickle.load(f)
        #     print("... ok [{0}]".format(time.time() - t1))

    @property
    def sm_nr(self): return self.__sm_nr
    @property
    def sass(self): return self.__sass
    @property
    def regs(self): return self.__regs
    @property
    def url(self): return self.__url

    def get_enc_vals(self, class_name:str, ankers:dict, exceptions:dict) -> typing.Tuple[typing.List[BitVector], typing.Dict[str,SASS_Bits]]:
        return SM_CuBin_Service_Lib.get_instr_bits(self.__sm_nr, class_name, ankers, exceptions, self.__url)

    @staticmethod
    def filterd_to_f(kk_sm:KK_SM, p_filter:typing.Callable):
        candidates = [c for c,i in kk_sm.kk_instr.items() if p_filter(i)]
        # i.has_dst and i.has_src and not i.has_mem and not i.has_imm and i.has_pred and i.has_cl and not i.is_alt and not i.has_reuse
        with open('filtered.log', 'w') as f:
            for c in candidates:
                f.write(str(kk_sm.kk_instr[c].class_))
                f.write('\n============================\n')

    @staticmethod
    def bit_word_to_hex(bvl:typing.List[BitVector], prefix=True):
        """
        Turn 64 bits into 8 bits hex pairs. The output should correspond to the actual
        line inside a cubin as generated by 'smd -fcubin ./template_XX', if compared.
        """
        pp = '0x' if prefix else ''
        return [[pp + hex(int(i,2))[2:].zfill(2) for i in 
                 reversed(['0b' + "".join(str(b) for b in bv[i:(i+8)]) for i in range(0,len(bv),8)])]
                    for bv in bvl]
    
    @staticmethod
    def tXX_cubin_filename(sm_nr:int, class_name:str):
        return "t{0}.{1}".format(sm_nr, class_name)

    @staticmethod
    def bits_to_bytes(bvl:typing.List[BitVector]):
        bits = KK_SM.bit_word_to_hex(bvl, prefix=False)
        return b''.join([bytearray.fromhex("".join(bv)) for bv in bits])
    
    @staticmethod
    def replace_bytes(cubin_bb:bytes, offset:int, instr_bytes:bytes):
        if not isinstance(cubin_bb, bytes): raise Exception(sp.CONST__ERROR_UNEXPECTED)
        if not isinstance(instr_bytes, bytes): raise Exception(sp.CONST__ERROR_UNEXPECTED)
        if not isinstance(offset, int): raise Exception(sp.CONST__ERROR_UNEXPECTED)
        return cubin_bb[:offset] + instr_bytes + cubin_bb[(offset+16):]
    
    @staticmethod
    def bytes_to_exec(location:str, cubin_filename:str, cubin_bytes:bytes):
        if not isinstance(location, str): raise Exception(sp.CONST__ERROR_ILLEGAL)
        if not isinstance(cubin_filename, str): raise Exception(sp.CONST__ERROR_ILLEGAL)
        if not isinstance(cubin_bytes, bytes): raise Exception(sp.CONST__ERROR_ILLEGAL)
        if not os.path.exists(location): raise Exception(sp.CONST__ERROR_ILLEGAL)
        
        if not location.endswith('/'): location += '/'
        with open(location + cubin_filename, 'wb') as f: f.write(cubin_bytes)
    
    @staticmethod   
    def get_NOP_cashes():
        """
        Return a dict with the fixed values required for a proper 'nop_' instruction class
        """
        return {
            'req_bit_set': {SASS_Bits.from_int(0)},
            'usched_info': {SASS_Bits.from_int(0)},
            'batch_t': {SASS_Bits.from_int(0)},
            'pm_pred': {SASS_Bits.from_int(0)}
        }
    
    @staticmethod   
    def get_subst_cashes(usched_info = 0x5):
        return {
            'req_bit_set': {SASS_Bits.from_int(0)},
            'usched_info': {SASS_Bits.from_int(usched_info)},
            'batch_t': {SASS_Bits.from_int(0)},
            'pm_pred': {SASS_Bits.from_int(0)},
            'src_rel_sb': {SASS_Bits.from_int(7)},
            'dst_wr_sb': {SASS_Bits.from_int(7)}
        }

if __name__ == '__main__':
    sms = [50,52,53,60,61,62,70,72,75,80,86,90,100,120]
    sms = [86]
    for sm in sms:
        kk_sm = KK_SM(sm, ip='127.0.0.1', port=8180, webload=True)
