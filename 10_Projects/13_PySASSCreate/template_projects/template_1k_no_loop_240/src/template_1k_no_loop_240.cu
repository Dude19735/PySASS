
/**
 * 
 * ===========================================================================================================
 * IMPORTANT: This file is autogenerated. Do not change!!
 * ===========================================================================================================
 * [KernelCount]1[/KernelCount]
 */

#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <iostream>
#include <fstream>
#include <algorithm>
#include <thread>
#include <format>
#include <vector>
#include <chrono>
#include <map>
#include <string>
#include <unordered_map>
#include <stdint.h>

__global__ void 
Kernel_0(unsigned int a, uint64_t *control, uint64_t *ui_output, double* d_output, uint64_t* ui_input, double* d_input, uint64_t *clk_out_1, float* f_output) {
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        ui_output[i] = static_cast<int>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        d_output[i] = 4.258798258 + static_cast<double>(a + static_cast<int>(a * (static_cast<float>(t2-t1) + 1.375f)));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        ui_output[i] = static_cast<int>(a * (static_cast<float>(t2-t1) + 1.256f));
    }
    #pragma unroll 2
    for(unsigned int i=0; i<a; ++i){
        int64_t t1 = clock64();
        int64_t t2 = clock64();
        d_output[i] = 4.258798258 + static_cast<double>(a + static_cast<int>(a * (static_cast<float>(t2-t1) + 1.375f)));
    }
    return;
}

template<class T>
void print_out(const std::string& prefix, const std::string& label, const std::vector<T>& data) {
    size_t ss = data.size();
    std::cout << prefix << "[" << label << "]";
    for(int i=0; i<ss; ++i){
        std::cout << data[i];
        if(i<(ss-1)) std::cout << ", ";
    }
    std::cout << "[/" << label << "]" << std::endl;
}

void print_out_single(const std::string& prefix, const std::string& label, const char* data) {
    std::cout << prefix << "[" << label << "]" << data << "[/" << label << "]" << std::endl;
}

int run_test(void* kernel_ptr, unsigned int input, unsigned int data_size, const std::string& filename, int kernel_index, const std::string& kernel_name, const std::string& enc_vals, const std::vector<uint64_t>& ui_input_params){
    std::cout << "[Kernel_" << kernel_index << "]" << std::endl;
    
    // print enc vals
    std::cout << "[EncVals]" << std::endl;
    std::cout << kernel_name << "|" << enc_vals << std::endl;
    std::cout << "[/EncVals]" << std::endl;

    uint64_t addr = reinterpret_cast<uint64_t>(kernel_ptr);
    std::cout << "[KernelAddress]0x" << std::format("{:x}", addr) << "[/KernelAddress]" << std::endl; 

    std::cout << "   [LoopCount_0]" << std::endl;
    // ==================================================================================================
    // Define input data
    // ==================================================================================================
    int control_size = 15;
    int printout = data_size;
    std::vector<uint64_t> control(control_size);
    std::vector<uint64_t> ui_output(printout);
    std::vector<double> d_output(printout);
    std::vector<float> f_output(printout);
    std::vector<uint64_t> ui_input(printout);
    std::vector<double> d_input(printout);
    std::vector<uint64_t> clk_out_1(printout);
    for(int i=0; i<control.size(); ++i) control[i] = 0;
    for(int i=0; i<ui_output.size(); ++i) ui_output[i] = 0;
    for(int i=0; i<d_output.size(); ++i) d_output[i] = 0.0;
    for(int i=0; i<f_output.size(); ++i) f_output[i] = static_cast<float>(i+10001);;
    // Use some of user defined input, if it exists
    for(size_t i=0; i<ui_input_params.size(); ++i) ui_input[i] = ui_input_params[i];
    for(size_t i=ui_input_params.size(); i<ui_input.size(); ++i) ui_input[i] = i+10001;
    for(int i=0; i<d_input.size(); ++i) d_input[i] = static_cast<double>(i+10001);
    for(int i=0; i<clk_out_1.size(); ++i) clk_out_1[i] = 999999998;

    // ==================================================================================================
    // Print input data
    // ==================================================================================================
    std::cout << "      [BeforeKernel]" << std::endl;
    print_out("         ", "Control", control);
    print_out("         ", "UiOutput", ui_output);
    print_out("         ", "DOutput", d_output);
    print_out("         ", "FOutput", f_output);
    print_out("         ", "UiInput", ui_input);
    print_out("         ", "DInput", d_input);
    print_out("         ", "ClkOut1", clk_out_1);

    // ==================================================================================================
    // Copy input data to GPU
    // ==================================================================================================
    uint64_t* device_control;
    cudaMalloc(&device_control, control.size()*sizeof(uint64_t));
    cudaMemcpy(device_control, control.data(), control.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    uint64_t* device_ui_output;
    cudaMalloc(&device_ui_output, ui_output.size()*sizeof(uint64_t));
    cudaMemcpy(device_ui_output, ui_output.data(), ui_output.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    double* device_d_output;
    cudaMalloc(&device_d_output, d_output.size()*sizeof(double));
    cudaMemcpy(device_d_output, d_output.data(), d_output.size()*sizeof(double), cudaMemcpyHostToDevice);

    float* device_f_output;
    cudaMalloc(&device_f_output, f_output.size()*sizeof(float));
    cudaMemcpy(device_f_output, f_output.data(), f_output.size()*sizeof(float), cudaMemcpyHostToDevice);

    uint64_t* device_ui_input;
    cudaMalloc(&device_ui_input, ui_input.size()*sizeof(uint64_t));
    cudaMemcpy(device_ui_input, ui_input.data(), ui_input.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    double* device_d_input;
    cudaMalloc(&device_d_input, d_input.size()*sizeof(double));
    cudaMemcpy(device_d_input, d_input.data(), d_input.size()*sizeof(double), cudaMemcpyHostToDevice);

    uint64_t* device_clk_out_1;
    cudaMalloc(&device_clk_out_1, clk_out_1.size()*sizeof(uint64_t));
    cudaMemcpy(device_clk_out_1, clk_out_1.data(), clk_out_1.size()*sizeof(uint64_t), cudaMemcpyHostToDevice);

    std::cout << "      [/BeforeKernel]" << std::endl;
    // ==================================================================================================
    // Run Kernel
    // ==================================================================================================
    // kernelT<<<1,1>>>(input, device_control, device_ui_output, device_d_output, device_ui_input, device_d_input, device_clk_out_1, device_f_output);
    void* args[] = {&input, &device_control, &device_ui_output, &device_d_output, &device_ui_input, &device_d_input, &device_clk_out_1, &device_f_output};
    cudaError_t err;
    err = cudaLaunchKernel(kernel_ptr, 1, 1, args, 0, nullptr);
    if ( err != cudaSuccess ) {
        print_out_single("         ", "CUDAError", cudaGetErrorString(err));
    }

    err = cudaDeviceSynchronize();
    if ( err != cudaSuccess ) {
        print_out_single("         ", "CUDAError", cudaGetErrorString(err));
    }

    err = cudaGetLastError();
    if ( err != cudaSuccess ) {
        print_out_single("         ", "CUDAError", cudaGetErrorString(err));
    }

    std::cout << "      [AfterKernel]" << std::endl;

    // ==================================================================================================
    // Copy output data to CPU
    // ==================================================================================================
    cudaMemcpy(control.data(), device_control, control.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(ui_output.data(), device_ui_output, ui_output.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(d_output.data(), device_d_output, d_output.size()*sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(f_output.data(), device_f_output, f_output.size()*sizeof(float), cudaMemcpyDeviceToHost);
    cudaMemcpy(ui_input.data(), device_ui_input, ui_input.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(d_input.data(), device_d_input, d_input.size()*sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(clk_out_1.data(), device_clk_out_1, clk_out_1.size()*sizeof(uint64_t), cudaMemcpyDeviceToHost);
    cudaFree(device_control);
    cudaFree(device_ui_output);
    cudaFree(device_d_output);
    cudaFree(device_f_output);
    cudaFree(device_ui_input);
    cudaFree(device_d_input);
    cudaFree(device_clk_out_1);

    // ==================================================================================================
    // Print output data
    // ==================================================================================================
    print_out("         ", "Control", control);
    print_out("         ", "UiOutput", ui_output);
    print_out("         ", "DOutput", d_output);
    print_out("         ", "FOutput", f_output);
    print_out("         ", "UiInput", ui_input);
    print_out("         ", "DInput", d_input);
    print_out("         ", "ClkOut1", clk_out_1);

    std::cout << "      [/AfterKernel]" << std::endl;
    std::cout << "   [/LoopCount_0]" << std::endl;

    std::cout << "[/Kernel_" << kernel_index << "]" << std::endl;

    return 0;
}

int main(int argc, char** argv){
    std::string fn = std::string(argv[0]);
    int split_ind = fn.find_last_of("/") + 1;
    std::string path = fn.substr(0,split_ind);
    std::string filename = fn.substr(split_ind);

    if(argc < 3){
        std::cout << std::vformat("{0} [input] [bin_location]", std::make_format_args(fn)) << std::endl;
        std::cout << " * [data size]: an integer expressing how large the input/output data arrays are" << std::endl;
        std::cout << " * [a input]: an integer that is passed to the kernel" << std::endl;
        std::cout << " * [ ... ]: non-comma separated list of integers to fill the data size, as long as there is space" << std::endl;
        return 0;
    }
    unsigned int data_size = static_cast<unsigned int>(std::stoi(argv[1]));
    unsigned int input = static_cast<unsigned int>(std::stoi(argv[2]));

    std::cout << "[Filename]" << filename << "[/Filename] [Input]" << input << "[/Input] ";

    std::map<std::string, void*> kernel_ptr = {{"Kernel_0", reinterpret_cast<void*>(&Kernel_0)}};
    
    std::vector<uint64_t> ui_input_params;
    for(int i=3; i<argc; ++i) ui_input_params.push_back(std::stoi(argv[i]));
    
    run_test(kernel_ptr["Kernel_0"], input, data_size, filename, 0, "Kernel_0", "", ui_input_params);

    return 0;
}